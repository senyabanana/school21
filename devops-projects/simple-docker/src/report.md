# Simple Docker

## Part 1. Готовый докер

* Если Docker не установлен на систему - устанавливаем командой `sudo apt install docker.io` <br/>
* Выполним несколько команды, которые требуются по заданию:<br>
    1. Взять официальный докер образ с nginx и выкачать его при помощи `docker pull`<br>
    2. Проверить наличие докер образа через `docker images` <br>
    3. Запустить докер образ через `docker run -d [image_id|repository]`<br>
    4. Проверить, что образ запустился через `docker ps`<br>
    ![pull](pictures/part1.png)<br>*Образ nginx: установка и проверка*<br>
* Посмотреть информацию о контейнере через `docker inspect 71a89f42fc41`<br>
* По выводу команды определить и поместить в отчёт размер контейнера, список замапленных портов и ip контейнера<br>
    ![size](pictures/part1.1.png)<br>*Размер контейнера*<br>
    ![size](pictures/part1.2.png)<br>*Список замапленных портов*<br>
    ![size](pictures/part1.3.png)<br>*IP контейнера*<br>
* Остановить докер образ через `docker stop [container_id|container_name]`<br>
    ![stop](pictures/part1.4.png)<br>*Остановка образа*<br>
* Запустить докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду run<br>
* Проверить, что в браузере по адресу localhost:80 доступна стартовая страница nginx<br>
    ![nginx](pictures/part1.5.png)<br>*Стартовая страница достпуна*<br>
* Перезапустить докер контейнер через `docker restart [container_id|container_name]`<br>
* Проверить любым способом, что контейнер запустился<br>
    ![restart](pictures/part1.6.png)<br>*Перезагрузка и проверка*<br>

## Part 2. Операции с контейнером

* Прочитать конфигурационный файл `nginx.conf` внутри докер контейнера через команду `exec`<br>
    ![exec](pictures/part2.png)<br>*файл nginx.conf*<br>
* Создать на локальной машине файл `nginx.conf`<br>
* Настроить в нем по пути `/status` отдачу страницы статуса сервера `nginx`<br>
    ![create](pictures/part2.1.png)<br>*Создание файла*<br>
* Скопировать созданный файл nginx.conf внутрь докер образа через команду `docker cp`<br>
* Перезапустить nginx внутри докер образа через команду `exec`<br>
* Проверить, что по адресу `localhost:80/status` отдается страничка со статусом сервера `nginx`<br>
    ![conf](pictures/part2.3.png)<br>*Копирование образа и перезапуск nginx, /status*<br>
* Экспортировать контейнер в файл container.tar через команду export<br>
* Остановить контейнер<br>
    ![export](pictures/part2.4.png)<br>*Экспорт и остановка*<br>
* Удалить образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры<br>
    ![delete](pictures/part2.5.png)<br>*Удаление образа*<br>
* Удалить остановленные контейнеры<br>
    ![delete](pictures/part2.6.png)<br>*Удаление остановленых контейнеров*<br>
* Импортировать контейнер обратно через команду `import`<br>
    ![import](pictures/part2.11.png)<br>*Импорт*<br>
* Запустить импортированный контейнер<br>
* Проверить, что по адресу `localhost:80/status` отдается страничка со статусом сервера `nginx`<br>
    ![nginx](pictures/part2.12.png)<br>*Запуск и проверка*<br>

## Part 3. Мини веб-сервер

* Выкачаем образ `nginx` и проверим его<br>
    ![nginx](pictures/part3.png)<br>*Образ nginx*<br>
* Установим утилиту `FastCGI`, а так же библиотеку для разработки<br>
    ![fastcgi](pictures/part3.1.png)<br>*Установка утилиты и библиотеки*<br>
* Напишем мини сервер на C и FastCgi, который будет возвращать простейшую страничку с надписью Hello World!<br>
    ![server](pictures/part3.2.png)<br>*Сервер на C и FastCGI*<br>
    1. `FCGI_Accept()` - это функция, предоставляемая библиотекой FastCGI, которая ожидает и принимает новый HTTP-запрос от клиента (обычно веб-браузера). Когда новый запрос приходит к FastCGI-приложению, FCGI_Accept() начинает его обработку<br>
    2. `while (FCGI_Accept() >= 0)` - это бесконечный цикл, который выполняется до тех пор, пока FCGI_Accept() возвращает неотрицательное значение. Если FCGI_Accept() возвращает отрицательное значение, это обычно указывает на ошибку или завершение работы приложения<br>
    3. `Content-type: text/html\r\n` - Это HTTP-заголовок, который указывает тип контента, который будет отправлен в ответ на запрос. В данном случае, тип контента установлен как "text/html", что означает, что ответ будет в формате HTML<br>
* Устанавливаем компилятор `gcc` и запускаем написанный мини сервер на порту `8080`<br>
    ![server](pictures/part3.4.png)<br>*Запуск сервера*<br>
* Напишем свой `nginx.conf`, который будет проксировать все запросы с `81` порта на `127.0.0.1:8080`<br>
    ![conf](pictures/part3.5.png)<br>*Файл nginx.conf*<br>
    ![launch](pictures/part3.6.png)<br>*Запуск образа и проверка*<br>
* Копируем конфигурационный файл и сервер в докер контейнер<br>
    ![copy](pictures/part3.7.png)<br>*Копирование файлов*<br>
* Зайдем в контейнер и проверим, что файлы скопированы<br>
    ![check](pictures/part3.8.png)<br>*Успешная проверка*<br>
* Компиляция и запуск сервера. Перезагрузка контейнера и проверка, что отдается написанная страничка<br>
    ![checkonemore](pictures/part3.9.png)<br>*localhost:81*<br>

## Part 4. Свой докер

* Создадим файл-скрипт, который будет запускать сервер<br>
    ![script](pictures/part4.png)<br>*Файл-скрипт start-server.sh*<br>
* Создадим докер образа<br>
    ![dockerfile](pictures/part4.1.png)<br>*Dockerfile*<br>
* Собираем написанный докер образ через `docker build` при этом указав имя и тег<br>
    ![build](pictures/part4.2.png)<br>*Сборка образа*<br>
* Проверить через `docker images`, что все собралось корректно<br>
    ![check](pictures/part4.3.png)<br>*Проверка*<br>
* Запускаем собранный образ с **маппингом `81 порта на 80`** и **маппингом папки `./nginx`** внутрь контейнера по адресу, где лежат конфигурационные файлы `nginx'а`<br>
* Проверим, что по `localhost:80` доступна страничка написанного мини сервера<br>
    ![run](pictures/part4.4.png)<br>*Запуск образа и проверка контейнера, проверка по адресу*<br>
* Допишем в `./nginx/nginx.conf` проксирование странички `/status`, по которой надо отдавать статус сервера `nginx`<br>
    ![status](pictures/part4.5.png)<br>*Добавление /status в конфигурационный файл*<br>
* Перезапускаем докер образ и проверяем, что теперь по `localhost:80/status` отдается страничка со статусом `nginx`<br>
    ![restart](pictures/part4.6.png)<br>*Перезапуск и провека*<br>
* Если всё сделано верно, то, после сохранения файла и перезапуска контейнера, конфигурационный файл внутри докер образа должен обновиться самостоятельно без лишних действий<br>
    ![check](pictures/part4.7.png)<br>*Проверка обновления изменений*<br>

## Part 5. Dockle

* Для работы с `Dockle` необходимо установить соответсвующую утилиту под конкретную операционную систему <https://github.com/goodwithtech/dockle#homebrew-mac-os-x--linux-and-wsl>
    ![dockle](pictures/part5.png)<br>*Установка утилиты*<br>
* Просканируем образ из предыдущего задания через `dockle [image_id|repository]`<br>
    ![scan](pictures/part5.1.png)<br>*Сканирование образа*<br>
* Исправим `Dockerfile`, так чтобы при проверке не возникало ошибок и предупреждений, и соберем образ<br>
    ![build](pictures/part5.2.png)<br>*Сборка и проверка*<br>
* Повторно просканируем образ через `dockle [image_id|repository]`<br>
    ![scan](pictures/part5.3.png)<br>*Сканирование образа*<br>

## Part 6. Базовый Docker Compose

* Изменим конфигурационные файлы<br>
    ![nginx](pictures/part6.png)<br>*Файл nginx.conf*<br>
    ![sh](pictures/part6.1.png)<br>*Файл .sh*<br>
* Создадим файл `docker-compose`<br>
    ![compose](pictures/part6.2.png)
* Остановим все запущенные контейнеры, если таковые имеются<br>
    ![ps](pictures/part6.3.png)<br>*Контейнеры*<br>
* Выполняем сборку проекта<br>
    ![build](pictures/part6.4.png)<br>*Выполняем команду*<br>
* Запускаем все контейнеры в режиме `detach`, что означает, что контейнеры будут работать в фоновом режиме<br>
* Проверяем, что контейнеры запустились<br>
* Проверяем страницу в браузере<br>
    ![up](pictures/part6.5.png)<br>*Успешно!*<br>
* Для остановки используется команда `stop` и для удаления - `down`<br>
    ![end](pictures/part6.6.png)<br>*Команды stop и down, проверка*<br>