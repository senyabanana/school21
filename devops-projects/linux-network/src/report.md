## Part 1. Инструмент ipcalc<br>
### Для удобства меняем **hostname** на **ws1**<br>
1. Сети и маски
    * Устанавливаем **ipcalc** командой `sudo apt install ipcalc`<br>
    ![Установка ipcalc](pictures/part1.png)<br>*Установка ipcalc*<br>
    1) Адрес сети **192.167.38.54/13** `ipcalc 192.167.38.54/13`<br>
    ![Адрес сети](pictures/part1.1.png)<br>*Адрес сети*<br>
    2) Перевод маски **255.255.255.0** в префиксную, двоичную запись `ipcalc 255.255.255.0`<br>
        * В префиксной записи будет **/24**. Потому что **255.255.255.0** представляет **24 бита** установленные в **1** (каждое "255" представляет 8 бит установленные в 1, и их три, так что 8 * 3 = 24)
        ![Двоичная запись](pictures/part1.2.png)<br>*Двоичная запись*<br>
    * **/15** в обычную и двоичную<br>
        * В обычной записи (десятичной) - **255.254.0.0**
        * В двоичную запись  `ipcalc /15` или `ipcalc 255.254.0.0`<br>
        ![Обычная и двоичная запись](pictures/part1.3.png)<br>*Обычная и двоичная запись*<br>
    * **11111111.11111111.11111111.11110000** в обычную и префиксную<br>
        * В обычной записи (десятичной) - **255.255.255.240**<br>
        * В првефиксной записи - **/28**, потому что 28 единиц<br>
        ![Префиксная запись](pictures/part1.4.png)*Префиксная запись*<br>
    3) Минимальный и максимальный хост<br>
    * Для определения минимального и максимального хоста в сети необходимо узнать, какая часть IP-адреса относится к адресу сети, а какая - к адресу хоста. Это определяется маской подсети. **Минимальный хост** - это первый доступный IP-адрес в сети, а **максимальный хост** - это последний доступный IP-адрес в сети.<br>
    * Минимальный и максимальный хост в сети **12.167.38.4** при масках:<br>
        * **/8** `ipcalc 12.167.38.4/8`<br>
        ![HostMin&HostMax](pictures/part1.5.png)<br>*HostMin & HostMax*<br>
        * **11111111.11111111.00000000.00000000 (эквивалентвно /16)** `ipcalc 12.167.38.4/16`<br>
        ![HostMin&HostMax](pictures/part1.6.png)<br>*HostMin & HostMax*<br>
        * **255.255.254.0 (эквивалентно /23)** `ipcalc 12.167.38.4/23`<br>
        ![HostMin&HostMax](pictures/part1.7.png)<br>*HostMin & HostMax*<br>
        * **/4** `ipcalc 12.167.38.4/4`<br>
        ![HostMin&HostMax](pictures/part1.8.png)<br>*HostMin & HostMax*<br>
2) localhost
    * **Адрес localhost** - это специальный адрес, который всегда указывает на "этот компьютер", то есть на ту машину, на которой выполняется текущая программа.<br>
    * Согласно стандартам, только IP-адреса в диапазоне **127.0.0.0 - 127.255.255.255** считаются адресами **loopback** и всегда указывают на **localhost**
    * **194.34.23.100** - выходит из диапазона **loopback**, поэтому обратиться к приложению по этому ip-адресу не сможем, `ipcalc 194.34.23.100`<br>
    ![194.34.23.100](pictures/part1.9.png)<br>*194.32.23.100*<br>
    * **127.0.0.2** - входит в диапазон, соответсвенно можем обратиться к приложению, `ipcalc 127.0.0.2`<br>
    ![127.0.0.2](pictures/part1.10.png)<br>*127.0.0.2*<br>
    * **127.1.0.1** - так же входит в диапазон, можем обратиться, `ipcalc 127.1.0.1`<br>
    ![127.1.0.1](pictures/part1.11.png)<br>*127.1.0.1*<br>
    * **128.0.0.1** - выходит из диапазона, обратиться не можем, `ipcalc 128.0.0.1`<br>
    ![128.0.0.1](pictures/part1.12.png)<br>*128.0.0.1*<br>
3) Диапазоны и сегменты сетей<br>
1.
    * **Частные адреса** не маршрутизируются в открытом интернете и обычно используются внутри локальных сетей. Все остальные адреса могут использоваться как **публичные IP-адреса**.<br>
    * **Частные диапазоны** IP-адресов включают в себя следующие:<br>
        - **10.0.0.0 - 10.255.255.255 (10.0.0.0/8)**<br>
        - **172.16.0.0 - 172.31.255.255 (172.16.0.0/12)**<br>
        - **192.168.0.0 - 192.168.255.255 (192.168.0.0/16)**<br>
    * **Исходя из этого:**<br>
    * **10.0.0.45** - Частный `ipcalc 10.0.0.45`<br>
    ![10.0.0.45](pictures/part1.13.png)*Private*<br>
    * **134.43.0.2** - Публичный `ipcalc 134.43.0.2`<br>
    ![134.43.0.2](pictures/part1.14.png)*Public*<br>
    * **192.168.4.2** - Частный `ipcalc 192.168.4.2`<br>
    ![192.168.4.2](pictures/part1.15.png)*Private*<br>
    * **172.20.250.4** - Частный `ipcalc 172.20.250.4`<br>
    ![172.20.250.4](pictures/part1.16.png)*Private*<br>
    * **172.0.2.1** - Публичный `ipcalc 172.0.2.1`<br>
    ![172.0.2.1](pictures/part1.17.png)*Public*<br>
    * **192.172.0.1** - Публичный `ipcalc 192.172.0.1`<br>
    ![192.172.0.1](pictures/part1.18.png)*Public*<br>
    * **172.68.0.2** - Публичный `ipcalc 172.68.0.2`<br>
    ![172.68.0.2](pictures/part1.19.png)*Public*<br>
    * **172.16.255.255** - Частный `ipcalc 172.16.255.255`<br>
    ![172.16.255.255](pictures/part1.20.png)*Private*<br>
    * **10.10.10.10** - Частный `ipcalc 10.10.10.10`<br>
    ![10.10.10.10](pictures/part1.21.png)*Private*<br>
    * **192.169.168.1** - Публичный `ipcalc 192.169.168.1`<br>
    ![192.169.168.1](pictures/part1.22.png)*Public*<br>
2.
    * Какие из перечисленных IP адресов шлюза возможны у сети **10.10.0.0/18**
    * Находим диапазон адресов, который определяется подсетью **(/18)** `ipcalc 10.10.0.0/18`<br>
    ![Диапазон](pictures/part1.23.png)*Диапазон: 10.10.0.0 - 10.10.63.255*<br>
    * Исходя из этого:<br>
        - **10.0.0.1** - Не возвможен<br>
        - **10.10.0.2** - Возможен<br>
        - **10.10.10.10** - Возможен<br>
        - **10.10.100.1** - Не возможен<br>
        - **10.10.1.255** - Возможен<br>

## Part 2. Статическая маршрутизация между двумя машинами<br>
1. 
    * Поднимаем две виртуальные машины **ws1** && **ws2**<br>
    * С помощью команды посмотреть существующие сетевые интерфейсы `ip a`<br>
    ![ip a](pictures/part2_ws1.png)*ip a ws1*<br>
    ![ip a](pictures/part2_ws2.png)*ip a ws2*<br>
    * Задаем адрес и маску для **ws1** с помощью VIM: `sudo vim /etc/netplan/*.yaml`<br>
    ![vim ws1](pictures/part2.1_ws1.png)*Сетевой интерфейс ws1*<br>
    * Задаем адрес и маску для **ws2** с помощью VIM: `sudo vim /etc/netplan/*.yaml`<br>
    ![vim ws2](pictures/part2.1_ws2.png)*Сетевой интерфейс ws2*<br>
    * Выполняем команду `sudo netplan apply` и смотрим `ip a`:<br>
    ![ws1](pictures/part2.2_ws1.png)*ws1*<br>
    * Выполняем команду `sudo netplan apply` и смотрим `ip a`:<br>
    ![ws2](pictures/part2.2_ws2.png)*ws2*<br>

2. Добавление статического маршрута вручную<br>
    * Добавление статического маршрута от одной машины до другой и обратно при помощи команды `ip r add`<br>
    * **ws1** - `sudo ip r add 172.24.116.8 dev enp0s3`<br>
    ![Добавление статического маршрута](pictures/part2.3_ws1.png)<br>*Добавление статического маршрута для ws1*<br>
    * **ws2** - `sudo ip r add 192.168.100.10 dev enp0s3`<br>
    ![Добавление статического маршрута](pictures/part2.3_ws2.png)<br>*Добавление статического маршрута для ws2*<br>
    * Пропинговать соединение между машинами:<br>
    * **ws1**<br>
    ![ws1](pictures/part2.4_ws1.png)<br>*ws1*<br>
    * **ws2**<br>
    ![ws2](pictures/part2.4_ws2.png)<br>*ws2*<br>
    <br>
    * Добавление статического маршрута с сохранением<br>
    * Перезагружаем виртуальные машины `sudo reboot`<br>
    * Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml<br>
    * **ws1:**<br>
    ![ws1](pictures/part2.5_ws1.png)*ws1*<br>
    * **ws2:**<br>
    ![ws2](pictures/part2.5_ws2.png)*ws2*<br>
    * Пропинговать соединение между машинами<br>
    * **ws1**<br>
    ![ws1](pictures/part2.6_ws1.png)<br>*ws1*<br>
    * **ws2**<br>
    ![ws2](pictures/part2.6_ws2.png)<br>*ws2*<br>

## Part 3. Утилита iperf3<br>
1. Скорость соединения<br>
    * Перевести и записать в отчёт:<br>
        - 8 Mbps - 1 MB/s<br>
        - 100 MB/s - 100000 Kbps<br>
        - 1 Gbps - 1000 Mbps<br>
2. Утилита iperf3<br>
    * Измерить скорость соединения между ws1 и ws2<br>
    * Устанавливаем утилиту **iperf** на каждую виртуальную машину командой `sudo apt install iperf3`<br>
    * При использовании утилиты `iperf3` для тестирования пропускной способности сначала запускается сервер, а затем клиент<br>
    * **ws1** выступает в роли сервера, **ws2** в роли клиента<br>
    * Запуск сервера `iperf3 -s`:<br>
    ![server](pictures/part3_ws1.png)*Запуск сервера*<br>
    * Сервер успешно запущен и готов принимать соединение от клиента<br>
    * Запуск клиента `iperf3 -c 192.168.100.10`:<br>
    ![client](pictures/part3.1_ws2.png)*Запуск клиента*<br>
    ![server](pictures/part3.1_ws1.png)*Соединение*<br>

## Part 4. Сетевой экран<br>
1. Утилита iptables<br>
    * Устанавливаем **iptables** на каждую машину командой `sudo apt install iptables`<br>
    * Создаем файл **/etc/firewall.sh**, имитирующий фаерволл, на каждой виртуальной машине `sudo vim /etc/firewall.sh`:<br>
    ![firewall](pictures/part4.png)*Firewall.sh*<br>
    * Добавляем в файл следующие правила:<br>
        - на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5)<br>
        - на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)<br>
        - открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)<br>
        - запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)<br>
        - разрешить echo reply (машина должна "пинговаться")<br>
    ![ws1](pictures/part4.1_ws1.png)*Firewall ws1*<br>
    ![ws2](pictures/part4.1_ws2.png)*Firewall ws2*<br>
    * Запустить файлы на обеих машинах командами `sudo chmod +x /etc/firewall.sh` и `sudo sh /etc/firewall.sh`<br>
    ![ws1](pictures/part4.2_ws1.png)*ws1*<br>
    ![ws2](pictures/part4.2_ws2.png)*ws2*<br>
    * Разница между стратегиями заключается в том, что на первой виртуальной машине (**ws1**) мы сначала запрещаем, а потом разрешаем, а во второй (**ws2**) - разрешаем, потом - запрещаем.<br>
2. Утилита **nmap**<br>
    * Устанавливаем **nmap** на каждую виртуальную машину командой `sudo apt install nmap`<br>
    * Пингуем виртуальные машины:<br>
    ![ws1](pictures/part4.3_ws1.png)*ws1 не пингуется*<br>
    * Видим надпись: `Host is up`<br>
    ![ws2](pictures/part4.3_ws2.png)*ws2 пингуется*<br>
    * **Создаем дампы виртуальных машин**<br>

## Part 5. Статическая маршрутизация сети<br>
### Поднимаем пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))<br>
![vm](pictures/part5.png)<br>*Виртуальные машины*<br>
1. Настройка адрессов машин<br>
    * Делаем настройку для каждой виртуальной машины, согласно рисунку, командой `sudo vim /etc/netplan/*.yaml`<br>
    ![ws11](pictures/part5.1_ws11.png)<br>*Настройка для ws11*<br>
    ![r1](pictures/part5_r1.png)<br>*Настройка для r1*<br>
    ![r2](pictures/part5_r2.png)<br>*Настройка для r2*<br>
    ![ws22](pictures/part5_ws22.png)<br>*Настройка для ws22<br>
    ![ws21](pictures/part5_ws21.png)<br>*Настройка для ws21<br>
    * Перезапускаем сервис сети командой `sudo netplan apply`. Если ошибок нет, то командой `ip -4 a` проверить, что адрес машины задан верно. Также пропинговать **ws22 с ws21**. Аналогично пропинговать **r1 с ws11**.<br>
    * **ws11, пингуем к r1**<br>
    ![ws11](pictures/part5.1_ws11.png)<br>*ws11*<br>
    * **ws21, пингуем к ws22**<br>
    ![ws21](pictures/part5.1_ws21.png)<br>*ws21*<br>
    * **ws22, пингуем к ws21**<br>
    ![ws22](pictures/part5.1_ws22.png)<br>*ws22*<br>
    * **r1, пингуем к ws11**<br>
    ![r1](pictures/part5.1_r1.png)<br>*r1*<br>
    * **r2**<br>
    ![r2](pictures/part5.2_r2.png)<br>*r2*<br>
2. Включение переадресации IP-адресов<br>
    * Для включения переадресации IP, выполните команду на роутерах: `sudo sysctl -w net.ipv4.ip_forward=1`<br>
    ![Переадресация для r1](pictures/part5.2_r1.png)*r1*<br>
    ![Переадресация для r2](pictures/part5.2_r2.png)*r2*<br>
    **При таком подходе переадресация не будет работать после перезагрузки системы**<br>
    * Откройте файл **/etc/sysctl.conf** и добавьте в него следующую строку: `net.ipv4.ip_forward = 1`<br>
    ![r1](pictures/part5.2.2_r1.png)*r1*<br>
    ![r2](pictures/part5.2.2_r2.png)*r2*<br>
    **При использовании этого подхода, IP-переадресация включена на постоянной основе**<br>
3. Установка маршрута по-умолчанию<br>
    * Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить **default** перед IP роутера (**gateway4**) в файле конфигураций<br>
    * Вызвать `ip r` и показать, что добавился маршрут в таблицу маршрутизации<br>
    ![ws11](pictures/part5.3.1_ws11.png)*ws11*<br>
    ![ws21](pictures/part5.3.1_ws21.png)*ws21*<br>
    ![ws22](pictures/part5.3.1_ws22.png)*ws22*<br>
    * Пропингуем с ws11 роутер r2, пинг не пройдёт, т.к. роутер "не знает" куда вернуть ответ, при этом передача пакетов с машины осуществляется<br>
    ![ws11](pictures/part5.3.2_ws11.png)*ping ws11*<br>
    `tcpdump -tn -i eth1`<br>
    * Изменим **eth1** на название нашего адаптера **enp0s8**<br>
    ![r2](pictures/part5.3.2_r2.png)*Вывод r2*<br>
4. Добавление статических маршрутов<br>
    * Добавить в роутеры **r1** и **r2** статические маршруты в файле конфигураций:<br>
    ![r1](pictures/part5.4_r1.png)*r1*<br>
    ![r2](pictures/part5.4_r2.png)*r2*<br>
    * Вызвать ip r и показать таблицы с маршрутами на обоих роутерах<br>
    ![r1](pictures/part5.4.1_r1.png)*r1*<br>
    ![r2](pictures/part5.4.1_r2.png)*r2*<br>
    * Запустить команды на **ws11**: `ip r list 10.10.0.0/[маска сети]` и `ip r list 0.0.0.0/0`<br>
    ![ws11](pictures/part5.4.2_ws11.png)*ws11*<br>
    * В отчете выбран путь отличный от **10.10.0.0** - этот адрес указывает на все адреса
5. Построение списка маршрутизаторов<br> 
    * Запускаем на **r1** команду дампа: `sudo tcpdump -tnv -i enp0s8`:<br>
    ![r1](pictures/part5.5_r1.png)*r1*<br>
    * Вместо **traceroute** я использовал альтернативу **mtr (MyTraceRoute)** `mtr 10.20.0.10`<br>
    ![ws11](pictures/part5.5_ws11.png)*ws11*<br>
    * Путь строится от узла к узлу до того момента, пока не будет достигнута конечная точка. Каждый пакет проходит на своем пути определенное количество узлов, пока не достигнет своей цели. На каждом узле добавляется счетчик, который отслеживает количество пройденых узлов<br>
6. Использование протокола ICMP при маршрутизации<br>
    * Запустить на **r1** перехват сетевого трафика, проходящего через **enp0s8** с помощью команды: `tcpdump -n -i enp0s8 icmp`<br>
    ![r1](pictures/part5.6_r1.png)*r1*<br>
    * Пропинговать с **ws11** несуществующий **IP** (например, **10.30.0.111**) с помощью команды: `ping -c 1 10.30.0.111`<br>
    ![ws11](pictures/part5.6_ws11.png)*ws11*<br>
    * Сохраняем дампы образов виртуальных машин<br>

## Динамическая настройка IP с помощью DHCP<br>
1. Чтобы работать с **DHCP**, необходимо установить утилиту **isc-dhcp-server**. Устанавливает ее командой `sudo apt-get install isc-dhcp-server`<br>
    * Настраиваем конфигурацию службы **DHCP** в файле **/etc/dhcp/dhcpd.conf** через **VIM**<br>
    * Указываем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети:
    ![r2](pictures/part6.1_r2.png)*Добавляем конфигурацию в конце файла*<br>
2. В файле resolv.conf прописать nameserver 8.8.8.8: `sudo vim /etc/resolv.conf`<br>
    ![r2](pictures/part6.2_r2.png)*resolv.conf r2*<br>
    * Перезагружаем службу **DHCP** командой `systemctl restart isc-dhcp-server`<br>
    ![Reboot dhcp](pictures/part6.2.1_r2.png)*Перезагрузка службы DHCP*<br>
    * Перезагружаем виртуальную машину **ws21** и через ip a показать, что она получила адрес:<br>
    ![ws21](pictures/part6.2.1_ws21.png)*ip a ws21*<br>
    * Проверяем пинг у **ws21** и **ws22**<br>
    ![ws21](pictures/part6.2.2_ws21.png)*Пингуем ws21 к ws22*<br>
    ![ws22](pictures/part6.2.2_ws22.png)*Пингуем ws22 к ws21*<br>
    * Указываем **MAC адрес** у **ws11**: **macaddress: 10:10:10:10:10:BA, dhcp4: true**
    ![macaddress](pictures/part6.2.3_ws11.png)*Указываем MAC адрес*<br>
    * Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу<br>
    * Устанавливаем DHCP `sudo apt-get install isc-dhcp-server`<br>
    * Настраиваем конфигурацию `sudo vim /etc/dhcp/dhcpd.conf`<br>
    ![r1](pictures/part6.2.4_r1.png)*Добавляем конфигурацию в конце файла*<br>
    * Вносим изменения в resolv.conf `sudo vim /etc/resolv.conf`<br>
    ![r1](pictures/part6.2.5_r1.png)*resolv.conf r1*<br>
    * Перезагружаем службу **DHCP** командой `systemctl restart isc-dhcp-server`<br>
    ![Reboot dhcp](pictures/part6.2.6_r1.png)*Перезагрузка службы DHCP*<br>
    * Перезагружаем виртуальную машину **ws11** и через ip a показать, что она получила адрес:<br>
    ![ws11](pictures/part6.2.6_ws11.png)*ip a ws11*<br>
    * Проверяем пинг у **ws11** и **ws22**<br>
    ![ws11](pictures/part6.2.7_ws11.png)*Пингуем ws11 к ws22*<br>
    ![ws22](pictures/part6.2.7_ws22.png)*Пингуем ws22 к ws11*<br>
    * Запрашиваем с **ws21** обновление ip адреса<br>
    ![ws21](pictures/part6.2.8_ws21.png)*ip до обновления*<br>
    * Запрашиваем с **ws21** обновление ip адреса с помощью команды `sudo dhclient -v`<br>
    ![ws21](pictures/part6.2.9_ws21.png)*Запрашиваем обновление*<br>
    ![ws21](pictures/part6.2.10_ws21.png)*ip после обновления*<br>
    * Выполняем команду `sudo dhclient -r`, чтобы очистить список ip адресов<br>
    ![ws21](pictures/part6.2.11_ws21.png)<br>*Очищаем список*<br>
    * В данном пункте пользовался опциями `-v` и `-r`<br>

## Part 7. NAT<br>
* Для работы с **apache2**, установим его на машины **ws22** и **r1**: `sudo apt install apache2`<br>
1. Делаем сервер **Apache2** общедоступным<br>
    * В файле **/etc/apache2/ports.conf** на **ws22** и **r1** изменить строку **Listen 80** на **Listen 0.0.0.0:80**<br>
    ![ws22 r1](pictures/part7.1_ws22_r1.png)*ws22 и r1*<br>
    * Запускаем сервер **Apache2** командой `service apache2 start` на **ws22** и **r1**<br>
    ![ws22](pictures/part7.1_ws22.png)*ws22*<br>
    ![r1](pictures/part7.1_r1.png)*wr1*<br>
2. Делаем фаервол на **r2** со следующими правилами:<br>
    1) удаление правил в таблице filter - `iptables -F`<br>
    2) удаление правил в таблице "NAT" - `iptables -F -t nat`<br>
    3) отбрасывать все маршрутизируемые пакеты - `iptables --policy FORWARD DROP`<br>
    ![r2](pictures/part7.2_r2.png)<br>*firewall r2*<br>
    * Запустим файл командами:<br>
    `sudo chmod +x /etc/firewall.sh` и `sudo bash /etc/firewall.sh`<br>
    ![r2](pictures/part7.2.1_r2.png)*r2*<br>
    * При запуске файла **firewall.sh** с этими правилами, **ws22** не должна "пинговаться" с **r1**<br>
    `ping -c 4 10.100.0.11` на **ws22**<br>
    ![ws22](pictures/part7.2.1_ws22.png)*Пингуем ws22 к r1*<br>
    * Добавляем в фаервол еще одно правило:<br>
    4) разрешить маршрутизацию всех пакетов протокола **ICMP**<br>
    ![r2](pictures/part7.2.2_r2.png)<br>*firewall r2*<br>
    * Запустим файл командой `sudo bash /etc/firewall.sh` и теперь **ws22** должна пинговаться с **r1**<br>
    ![ws22](pictures/part7.2.3_ws22.png)*Пингуем ws22 к r1*<br>
    ![r1](pictures/part7.2.3_r1.png)*Пингуем r1 к ws22*<br>
    * Добавляем в фаервол еще два правила:<br>
    5) включить **SNAT**, а именно маскирование всех локальных ip из локальной сети, находящейся за **r2** (по обозначениям из Части 5 - сеть 10.20.0.0)<br>
    6) включить **DNAT** на 8080 порт машины **r2** и добавить к веб-серверу **Apache**, запущенному на **ws22**, доступ извне сети<br>
    ![r2](pictures/part7.3_r2.png)*Добавляем изменения в firewall*<br>
    * Запустим файл командой `sudo bash /etc/firewall.sh` и проверим соединение по **TCP** для **SNAT**, для этого с **ws22** подключимся к серверу **apache** на **r1** `telnet [адрес] [порт]`<br>
    ![ws22](pictures/part7.3_ws22.png)<br>*Проверяем соединение*<br>
    * Проверить подмену IP-адреса можно с помощью команды **tcpdump** - пингуем с машины **ws22 роутер r1**, в выводе **tcpdump** будет отображаться с какого адреса идет запрос - **IP-адрес r2**<br>
    * Пингует **ws22** к **r1**<br>
    ![r1](pictures/part7.4_ws22.png)*Пингуем r1 к ws22*<br>
    * `sudo tcpdump -i enp0s9`<br>
    ![tcpdump](pictures/part7.4_r1.png)*Проверяем подмену IP-адреса*<br>
    * Для проверки соединения по **TCP** для **DNAT** нужно отключить **NAT (enp0s3)** на **ws22**<br>
    * Подключаемся к серверу **Apache** на **ws22** (обращаться по адресу **r2** и порту **8080**)<br>
    * `telnet [адрес] 8080`<br>
    ![r1](pictures/part7.5_r1.png)<br>*Подключаемся к серверу*<br>
    * Проверяем соединение:<br>
    * `sudo tcpdump -i enp0s8`<br>
    ![tcpdump](pictures/part7.5_ws22.png)*Проверяем соединение*<br>
    * Сохраняем дампы виртуальных машин<br>

## Part 8. Дополнительно. Знакомство с SSH Tunnels<br>
0. * Запустим фаервол на **r2** командами: `sudo chmod +x /etc/firewall.sh` и `sudo bash /etc/firewall.sh`<br>
    * Запускаем веб-сервер **Apache** на **ws22** только на **localhost** (то есть в файле **/etc/apache2/ports.conf** изменить строку **Listen 80** на **Listen localhost:80**)<br>
    ![ws22](pictures/part8_ws22.png)*Меняем на localhost*<br>
    * Проверяем статус **Apache**:<br>
    ![ws22](pictures/part8.1_ws22.png)*Проверяем статус*<br>
1. * Воспользоваться **Local TCP forwarding с ws21 до ws22**, чтобы получить доступ к веб-серверу на **ws22 с ws21**<br>
    * На виртуальной машине **ws21** выполняем команду `ssh -L local_port:ws22_ip:web_server_port user@localhost`, где:<br>
    * `local_port` - порт, на котором находится веб-сервер<br>
    * `ws22_ip` - IP-адрес виртуальной машины **ws22**<br>
    * `web_server_port` - порт, на котором находится веб-сервер<br>
    * `user` - имя пользователя<br>
    ![ws21](pictures/part8.2_ws21.png)<br>
    * На машине **ws22** запускаем утилиту **telnet**<br>
    ![ws22](pictures/part8.2_ws22.png)<br>*Видим сервер*<br>
2. Воспользоваться **Remote TCP forwarding c ws11 до ws22**, чтобы получить доступ к веб-серверу на **ws22** с **ws11**<br>
    * На виртуальной машине **ws11** выполняем команду `ssh -R remote_port:ws22_ip:web_server_port user@localhost`, где:<br>
    * `remote_port` - порт на ws22, через который будет доступен веб-сервер<br>
    * `ws22_ip` - IP-адрес виртуальной машины **ws22**<br>
    * `web_server_port` - порт, на котором находится веб-сервер<br>
    * `user` - имя пользователя<br>
    ![ws11](pictures/part8.3_ws11.png)<br>
    * На машине **ws22** запускаем утилиту **telnet**<br>
    ![ws22](pictures/part8.3_ws22.png)<br>*Видим сервер*<br>
    * Сохраняем дампы виртуальных машин<br>